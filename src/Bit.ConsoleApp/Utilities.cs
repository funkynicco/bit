using System;
using System.Collections.Generic;
using System.IO;
using System.Text;

namespace Bit.ConsoleApp
{
    public static class Utilities
    {
        private const string HexCharacters = "0123456789abcdef";
        private static readonly byte[] _hexMap =
        {
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 16
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 32
            0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 48
    /*A-F*/ 0x00, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 64
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 80
    /*a-f*/ 0x00, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 96
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 112
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 128
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 144
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 160
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 176
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 192
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 208
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 224
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 240
        };

        public static bool TryFindFolder(string name, out string path)
        {
            var dir = Environment.CurrentDirectory;
            while (true)
            {
                var cur = Path.Combine(dir, name);
                if (Directory.Exists(cur))
                {
                    path = cur;
                    return true;
                }

                var previous_dir = Path.GetDirectoryName(dir);
                if (previous_dir == null)
                    break;

                dir = previous_dir;
            }

            path = null;
            return false;
        }

        public static IReadOnlyList<ReadOnlyMemory<char>> SplitPathIntoParts(ReadOnlyMemory<char> path)
        {
            var span = path.Span;
            var parts = new List<ReadOnlyMemory<char>>(32);

            var start = 0;
            for (int i = 0; i <= path.Length; ++i)
            {
                if (i == path.Length ||
                    span[i] == '/' ||
                    span[i] == '\\')
                {
                    if (i > start)
                        parts.Add(path.Slice(start, i - start));

                    start = i + 1;
                }
            }

            return parts;
        }

        public static string ToHex(ReadOnlySpan<byte> bytes)
        {
            var hex = "0123456789abcdef";
            var sb = new StringBuilder(32);

            for (int i = 0; i < bytes.Length; i++)
            {
                var b = bytes[i];
                sb.Append(hex[b >> 4]);
                sb.Append(hex[b & 0xf]);
            }

            return sb.ToString();
        }

        public static byte[] FromHex(ReadOnlySpan<char> hex)
        {
            if (hex.Length % 2 != 0)
                throw new ArgumentException($"Argument must be valid hex.");

            var bytes = new byte[hex.Length / 2];
            var count = 0;

            for (int i = 0; i < hex.Length; i += 2)
            {
                bytes[count++] = (byte)(_hexMap[hex[i]] << 4 | _hexMap[hex[i + 1]]);
            }

            return bytes;
        }

        public static string GenerateRandomHash()
            => ToHex(Guid.NewGuid().ToByteArray());
    }
}
